\chapter{Garbage collection}
\label{chap-garbage-collection}

\section{Introduction}

Contrary to traditional operating systems such as \unix{}, a Lisp
operating system will need a global \emph{tracing garbage collector}.
Traditional operating systems get away with a simpler technique,
because the file system in such an operating system can not contain
cycles.  With this restriction, the simpler \texttt{reference
  counting} mechanism is sufficient.  Furthermore, although reference
counting is usually slower than a tracing garbage collector, the
additional overhead of reference counters is of no importance when
used for a file system in secondary memory.

There is a rich literature on automatic memory management.
(see e.g., \cite{Jones:2011:GCH:2025255})

\section{Per-thread garbage collector}

Each thread has a local heap, roughly the size of the cache, say
around 4MiB.  The thread-local heap is managed entirely by the thread
itself, so that the garbage collector for it is executed by the thread
itself.  Experiments show that we will be able to run the thread-local
garbage collector in a few milliseconds, which is good enough for most
applications.  We will use a sliding garbage collector in order to
maintain allocation order.  This way, we have a precise measure of the
relative age of the objects, so that we can promote only the oldest
objects when required. 

\section{Global garbage collector}

In addition to the thread-local heaps, there is a global heap.  The
garbage collector for this heap will use a combination of the
traditional \emph{mark-and-sweep} collector and an ordinary memory
allocator, similar to the one used by the \clanguage{} functions
\texttt{malloc} and \texttt{free}.
